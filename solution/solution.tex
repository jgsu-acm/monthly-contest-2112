\documentclass{ctsol}

\title{ACM算法与微应用实验室2021年12月月赛题解}
\date{2021年12月26日}

\begin{document}
\maketitle
\addsolution{Again! Again!}{AgOH}{数论}
\addsolution{Base! Base!}{Zxilly}{模拟}
\addsolution{Move! Move!}{AgOH}{贪心+链表}
\addsolution{Happy! Happy!}{AgOH}{完全背包}
\addsolution{Pair! Pair!}{AgOH}{枚举}
\addsolution{Balloon! Balloon!}{AgOH}{模拟}

\section*{题目概览}
\solutiontab

\makesolution
\section*{做法}

按照题意求出连分数的值后进行有理数取余即可得出答案。

因为模数是质数，故可以采取简单的快速幂法求逆元。

\section*{标程}
\std{A}

\makesolution
\section*{做法}

根据题意模拟即可，二进制有关操作可以使用 \verb|bitset| 来轻松搞定。

\section*{标程}
\std{B}

\makesolution
\section*{做法}

首先，看到“字典序最大”马上就想到了这题肯定是贪心。

然后我们发现会有多次在 $P$ 中进行删除的操作，又想到可以使用链表进行快速删除的操作。

于是此题就做出来了：对 $P$ 开出一个链表，并记录下每个数字 $i$ 所在的位置 $pos[i]$，然后我们贪心地从 $n$ 到 $1$ 遍历 $i$，如果能够输出（$pos[i]$ 位置以及 $pos[i]$ 的后一个位置上的两个数都存在）就输出，直到遍历完即可得出结果。时间复杂度为 $O(n)$。

标程中使用 STL 中的 \verb|list| 来实现链表。因为只有删除操作，所以整个过程中 \verb|ls.end()| 是肯定不会改变的，所以我们可以用它来标记某个数被删除掉了。

\section*{标程}
\std{C}

\makesolution
\section*{做法}

很显然这是一道物品价值与重量相等的完全背包题目，写个板子上去就搞定了。

\section*{标程}
\std{D}

\makesolution
\section*{做法}

枚举 $i+j$ 的值，并判断是否满足条件即可。

\section*{标程}
\std{E}

\makesolution
\section*{做法}

我们需要记录一个字符串出现了多少次，很显然使用一个 \verb|map<string,int>| 就可以把某字符串本身到其出现的次数的映射存下了。

\section*{标程}
\std{F}

\end{document}